"""Функции для генерации и решения лабиринта"""

import random

from queue import PriorityQueue
from typing import Any


def generate(width: int, height: int) -> [[]]:
    """
    Генерация лабиринта с помощью алгоритма Эйлера
    :param width: Ширина лабиринта
    :param height: Высота лабиринта
    :return: Сгенерированный лабиринт
    """

    # Проверим ограничения параметров на 0
    if (width < 1) or (height < 1):
        return None

    top_limit = 2 ** 32 - 1
    # Проверим ограничения по максимальному допустимому размеру
    if ((top_limit - 1) // 2 <= width) or ((top_limit - 1) // 2 <= height):
        return None

    # Инициализируем размер конечной матрицы maze
    # Ячейки будут представлять собой фрагменты 2x2 + 1 одно значение
    # сверху и слева для стен
    output_height = height * 2 + 1
    output_width = width * 2 + 1
    # Инициализируем лабиринт
    maze = [['█' for j in range(output_width)] for i in range(output_height)]

    # Инициализируем построчно пустой лабиринт со стенами по периметру
    # и "опорами" (стенами) в нижнем правом углу ячеек 2x2
    # ███████
    # █     █
    # █ █ █ █
    # █     █
    # ███████
    for i in range(output_height):
        for j in range(output_width):
            # Если этот элемент в строке является ячейкой в левом верхнем
            # угле области 2x2 - то это пустая ячейка в лабиринте
            if (i % 2 == 1) and (j % 2 == 1):
                maze[i][j] = ' '
            # Если это область для стены справа или область для стены снизу
            # - то инициализируем этот элемент пустой ячейкой в лабиринте
            elif (((i % 2 == 1) and (j % 2 == 0) and (j != 0) and (
                    j != output_width - 1)) or (
                          (j % 2 == 1) and (i % 2 == 0) and (i != 0) and (
                          i != output_height - 1))):
                maze[i][j] = ' '
            else:
                # Во всех остальных случаях устанавливаем стену
                maze[i][j] = '█'

    # 1. Создаём первую строку лабиринта. Ни одна ячейка не будет принадлежать
    # какому - либо множеству.
    # Инициализируем вспомогательную строку, которая будет содержать в себе
    # принадлежность ко множеству для ячейки из алгоритма
    # 0 - будет означать, что ячейка не принадлежит никакому множеству
    row_set = [0] * width
    # И инициализируем счетчик для множеств
    count = 1
    # Инициализируем генератор случайных чисел
    random.seed()

    # Организуем цикл алгоритма Эйлера
    for i in range(height):
        # 2. Присваиваем каждой ячейке, которая не входит ни в одно множество,
        # своё уникальное множество.
        for j in range(width):
            if row_set[j] == 0:
                row_set[j] = count
                count += 1
        # 3. Создаём правые стены для ячеек, двигаясь слева направо,
        # следующим образом :
        for j in range(width - 1):
            # Случайным образом решаем, добавлять стену или нет
            right_wall = random.randint(0, 1)
            # Если текущая и ячейка справа являются членами одного и того
            # же множества, всегда создаём между ними стену
            # (это предотвратит петли)
            if right_wall == 1 or row_set[j] == row_set[j + 1]:
                # верхний ряд в i-ом ряду ячеек 2x2, Правый столбец в (i;j)
                # ячейке 2x2*
                maze[i * 2 + 1][j * 2 + 2] = '█'  # Создаём стену
            else:
                # Если мы решим не добавлять стену, то объединим множества,
                # к которым относятся текущая ячейка и ячейка справа
                changing_set = row_set[j + 1]
                for index in range(width):
                    if row_set[index] == changing_set:
                        row_set[index] = row_set[j]

        # 4. Создаём нижние стены, двигаясь слева направо:
        for j in range(width):
            # Случайным образом решаем, добавлять нижнюю стену или нет.
            bottom_wall = random.randint(0, 1)
            # Если ячейка является единственным членом своего множества, то не
            # создавайте нижнюю стену
            # pylint: disable=consider-using-generator
            count_current_set = sum(
                [row_set[l] == row_set[j] for l in range(width)])
            # Если ячейка является единственным членом своего множества,которая
            # не имеет нижней стены, то не создаём нижнюю стену
            if bottom_wall == 1 and count_current_set != 1:
                maze[i * 2 + 2][j * 2 + 1] = '█'

        # 5. Решаем, продолжать добавлять строки или остановиться и завершить
        # лабиринт. Если мы решим добавить еще одну строку:
        if i != height - 1:
            # Важно: Убедимся, что каждая область имеет по крайней мере одну
            # ячейку без нижней стены(это предотвратит создание
            # изолированных областей)
            for j in range(width):
                count_hole = sum(maze[i * 2 + 2][l * 2 +1] == ' ' and
                                row_set[l] == row_set[j] for l in range(width))
                if count_hole == 0:
                    maze[i * 2 + 2][j * 2 + 1] = ' '
            # * скопируем текущую строку
            # * удалим в новой строку все правые стены
            # Правые стенки в инициализированном массиве у нас уже отсутствуют
            # в каждой новой строке
            # * удалим ячейки с нижней стеной из их множества
            for j in range(width):
                # Проверим наличие нижней стены у текущего ряда
                if maze[i * 2 + 2][j * 2 + 1] == '█':
                    # Если стенка есть, то удаляем ячейку из множества
                    row_set[j] = 0
                    # * удалим все нижние стены
            # Нижние стены в каждом новом ряду ячеек отсутствуют (заложено при
            # инициализации)

        # * продолжить с шага 2.

    # Если мы решим закончить лабиринт:
    # добавим нижнюю стену каждой ячейке
    # Нижняя стена построена при инициализации лабиринта
    # перемещаемся слева направо:
    for j in range(width - 1):
        # Если текущая ячейка
        # и ячейка справа являются членами разных множеств, то:
        if row_set[j] != row_set[j + 1]:
            # удаляем правую стену
            maze[-2][j * 2 + 2] = ' '
            # объединяем множества, к которым принадлежат текущая ячейка и
            # ячейка справа
            # Это делать не обязательно, так как row_set мы больше не будем
            # использовать, а
            # все множества в конечном итоге станут одним, после удаления стен

    # Вернём полученный лабиринт
    return maze


def best_first_search(maze: [[]]) -> list:
    """
    Функция для решения лабиринта с помощью Best-first search.
    :param maze: Лабиринт
    :return: Список с координатами точек
    """
    # Задаем начальную и конечную точки лабиринта
    start = (1, 1)
    goal = (len(maze) - 2, len(maze[0]) - 2)

    # Создаем очередь с приоритетами и добавляем в нее начальную точку
    frontier = PriorityQueue()
    # Приоритетная очередь - это абстрактная структура данных, в которой каждый
    # элемент имеет определённый приоритет и извлекается в соответствии с ним.

    # Добавляем элемент в очередь
    frontier.put(start, False)

    # Словарь для хранения путей
    came_from = {start: None}

    while not frontier.empty():
        # Получаем следующую точку из очереди с приоритетами
        current = frontier.get()

        # Если мы достигли цели, то выходим из цикла
        if current == goal:
            break

        # Получаем соседние точки
        for next_point in get_neighbors(current, maze):
            # Если мы еще не были в этой точке
            if next_point not in came_from:
                # Вычисляем приоритет для этой точки
                # (т.е. используем функции оценки для определения того, какая
                # смежная вершина является наиболее обещающей для продолжения
                # поиска)
                priority = heuristic(goal, next_point)
                # Добавляем эту точку в очередь с приоритетами
                frontier.put(next_point, priority)
                # Добавляем путь до этой точки в словарь came_from
                came_from[next_point] = current

    # Восстанавливаем путь до цели из словаря came_from
    return reconstruct_path(came_from, start, goal)


def get_neighbors(pos: Any, maze: [[]]) -> list:
    """
    Получение соседних точек
    :param pos: Текущая позиция
    :param maze: Лабиринт
    :return: Список соседних точек
    """
    neighbors = []
    # Перебираем четыре направления: вверх, вниз, влево и вправо
    for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        # Считаем координаты соседней точки
        neighbor = (pos[0] + direction[0], pos[1] + direction[1])
        # Проверяем, что соседняя точка не является стеной лабиринта
        if maze[neighbor[0]][neighbor[1]] != '█':
            # Добавляем соседнюю точку в список соседей
            neighbors.append(neighbor)
    return neighbors


def heuristic(first_point: tuple, second_point: tuple) -> Any:
    """
    Вычисляет эвристическую функцию как манхеттенское расстояние между точками
    :param first_point: Координаты первой точки
    :param second_point: Координаты второй точки
    :return: Расстояние
    """
    return abs(first_point[0] - second_point[0]) + abs(first_point[1] -
                                                       second_point[1])


def reconstruct_path(came_from: dict, start: tuple, goal: tuple) ->list[tuple]:
    """
    Восстанавливает путь до цели.
    :param came_from: Словарь с путями
    :param start: Начальная точка
    :param goal: Конечная точка
    :return: Восстановленный путь
    """
    current = goal
    path = []
    # Идем от цели к началу по словарю came_from
    while current != start:
        # Добавляем текущую точку в путь
        path.append(current)
        # Переходим к предыдущей точке по пути
        current = came_from[current]
    # Добавляем начальную точку в путь
    path.append(start)
    # Переворачиваем путь, чтобы он шел от начала к цели
    path.reverse()
    return path
